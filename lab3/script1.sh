#!/bin/bash

#1) выводит в файл work3.log построчно список всех пользователей в системе в следующем формате:
#«user NNN has id MM»;
    cat /etc/passwd  | awk -F: '{print "user " $1 " has id " $3}' > work3.log
#2) добавляет в файл work3.log строку, содержащую дату последней смены пароля для пользователя
#root;
    echo "Root last changed password date:">> work3.log
    chage -l root | grep "Last password change" | cut -d: -f 2 >> work3.log
#3) добавляет в файл work3.log список всех групп в системе (только названия групп) через запятую;
    echo "All groups in system:" >> work3.log
    cat /etc/group | awk -F: '{print $1","}' >> work3.log
#4) делает так, чтобы при создании нового пользователя у него в домашнем каталоге создавался файл
#readme.txt с текстом «Be careful!»;
    echo "Be careful Frodo!" > /etc/skel/readme.txt
#5) создает пользователя u1 с паролем 12345678;
    useradd -p $(openssl passwd -crypt 12345678) u1
#6) создает группу g1;
    groupadd g1
#7) делает так, чтобы пользователь u1 дополнительно входил в группу g1;
    usermod -a -G g1 u1             #-a = To add anyone of the group to a secondary group
                                    #-G = To add a supplementary groups.
#8) добавляет в файл work3.log строку, содержащую сведения об идентификаторе и имени
#пользователя u1 и идентификаторах и именах всех групп, в которые он входит;
    u1_groups=$(groups u1 | cut -d: -f 2)
    u1_info=$(cat /etc/passwd | grep u1 | awk -F: '{print "username: " $1 " user_id: " $3 " user_groups: "}')
    echo "$u1_info $u1_groups" >> work3.log
#9) делает так, чтобы пользователь user дополнительно входил в группу g1
    usermod -a -G g1 user 
#10) добавляет в файл work3.log строку с перечнем пользователей в группе g1 через запятую;
    cat /etc/group | grep g1 | awk -F: '{print "group " $1 " has members: " $4 }' >> work3.log
#11) делает так, что при входе пользователя u1 в систему вместо оболочки bash автоматически
#запускается /usr/bin/mc, при выходе из которого пользователь возвращается к вводу логина и
#пароля
echo "/usr/bin/mc" >> /etc/shells #добавтить миднайт коммандер  в shell чтобы сhsh не ругалось
chsh -s /usr/bin/mc u1
#12) создает пользователя u2 с паролем 87654321;
    useradd -p $(openssl passwd -crypt 87654321) u2
#13) в каталоге /home создает каталог test13, в который копирует файл work3.log два раза с
#разными именами (work3-1.log и work3-2.log);
    mkdir ~/test13
    cp work3.log ~/test13/work3-1.log
    cp work3.log ~/test13/work3-2.log
#14) сделает так, чтобы пользователи u1 и u2 смогли бы просматривать каталог test13 и читать эти
#файлы, только пользователь u1 смог бы изменять и удалять их, а все остальные пользователи
#системы не могли просматривать содержимое каталога test13 и файлов в нем. При этом никто не
#должен иметь права исполнять эти файлы;
    chown u1:u2 ~/test13
    chown u1:u2 ~/test13/*
    chmod 750 ~/test13/
    chmod 640 ~/test13/*
#15) создает в каталоге /home каталог test14, в который любой пользователь системы сможет
#записать данные, но удалить любой файл сможет только пользователь, который его создал или
#пользователь u1;
    mkdir ~/test14
    chgrp -R u1 ~/test14
    chmod  1777 ~/test14
                                #1 sticky bit Из такого каталога пользователь может удалить только те файлы, владельцем которых он является
                                #0 - никаких прав;
                                #1 - только выполнение;
                                #2 - только запись;
                                #3 - выполнение и запись;
                                #4 -  только чтение;
                                #5 - чтение и выполнение;
                                #6 - чтение и запись;
                                #7 - чтение запись и выполнение.

#16) копирует в каталог test14 исполняемый файл редактора nano и делает так, чтобы любой
#пользователь смог изменять с его помощью файлы, созданные в пункте 13;
    cp /bin/nano ~/test14/nano
    chmod 4777 ~/test14/nano
                                #4 Когда атрибут setuid установлен файлу, обычный пользователь, запускающий этот файл на исполнение, получает 
                                #повышение прав до пользователя-владельца файла (обычно root) в рамках запущенного процесса.

#17) создает каталог test15 и создает в нем текстовый файл /test15/secret_file. Делает так, чтобы
#содержимое этого файла можно было вывести на экран, используя полный путь, но чтобы узнать
#имя этого файла, было бы невозможно.
    mkdir ~/test15
    echo "some secret info" > ~/test15/secret_file
    chmod 744 ~/test15/secret_file
    chmod 733 ~/test15
